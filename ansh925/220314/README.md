## 수영장
### SW1952
``` python
t=int(input())
for _ in range(1,t+1):
    cost=list(map(int,input().split()))
    plan=list(map(int,input().split()))

    dp=[0]*12

    dp[0]=min(cost[0]*plan[0], cost[1])
    dp[1]=dp[0]+min(cost[0]*plan[1], cost[1])
    dp[2]=min(dp[1]+min(cost[0]*plan[2], cost[1]), cost[2])
    for i in range(3,12):
        dp[i]=min(dp[i-3]+cost[2], dp[i-1]+min(cost[0]*plan[i], cost[1]))

    dp[-1]=min(dp[-1], cost[3])
```
> - 일일권,한달권,3개월권,1년권 단위로 구분해서 최소값을 비교해야 된다고 생각했고, 이용권 가격과 이용 계획을 list에 넣어서 dp를 사용하기로했다.   
> 3월달까지는 직접 최소값을 입력해주고, 그 이후는 for문을 돌며 일일권,한달권,3개월권 이용권을 비교했다.   
> dp list의 마지막 원소와 1년권을 비교하여 저 작은값을 출력한다.
> - 피보나치 등의 dp문제와 유사하게 처음 몇개를 직접 입력해준 뒤, 이후로는 for문을 돌며 점화식을 사용하는 방법을 떠올렸다.
   
   
## Z
### BJ1074

``` python
n,r,c=map(int,input().split())
ans=0
while n!=0:
    n-=1
    if r<2**n and c<2**n:
        ans+=(2**n)*(2**n)*0
    elif r<2**n and c>=2**n:
        ans+=(2**n)*(2**n)*1
        c-=2**n
    elif r>=2**n and c<2**n:
        ans+=(2**n)*(2**n)*2
        r-=2**n
    else:
        ans+=(2**n)*(2**n)*3
        c-=2**n
        r-=2**n
```
   
> - 4등분 될때마다 Z모양이 반복되도록 사분면을 기준으로 구분해서 해결했다.   
> 먼저 if 조건무을 통해 (r,c)가 위치한 사분면을 파악하고, n값을 1씩 줄여가며 한단계 작은 사분면에서도 위치를 파악해간다.   
> 한번의 while문을 돌때마다 방문한 횟수를 더하고, x축 및 y축 값은 감소시키며 n이 0이 될때까지 진행한다.
> - 처음 문제를 봤을때는 코드도 길고 어렵겠구나 생각했던거와 반대로, 천천히 읽어보고 떠오르는대로 코드를 작성했더니 풀려서 기분 좋았던 문제ㅎ   
   
   
## 다트게임
### PG17682

``` python
    divided=[]
    tmp=list(dartResult)
    for i in range(len(tmp)):
        if tmp[i]=='1' and tmp[i+1]=='0':   # 10인 경우 따로 처리
            divided.append('10')
        elif tmp[i]=='0' and tmp[i-1]=='1': # 마찬가지로 10인 경우 중복처리 제외
            continue
        else:
            divided.append(tmp[i])
    ans=[]
    for j in divided:
        if j.isdigit():
            num=int(j)
        elif j.isalpha():
            if j=='S':
                num**=1
                ans.append(num)
            elif j=='D':
                num**=2
                ans.append(num)
            elif j=='T':
                num**=3
                ans.append(num)
        if j=='*':
            if len(ans)>=2:
                ans[-1]*=2
                ans[-2]*=2
            else:
                ans[-1]*=2
        elif j=='#':
            ans[-1]*=(-1)
    return sum(ans) 
```   
   
   
> - 입력받은 문자열(점수,보너스,옵션) 중 점수(10점)만 유일하게 두자리를 차지하므로 따로 처리해준다.   
> 그 외의 경우에는 입력 받은 문자열을 한자리씩 모두 나누어 divided 리스트에 저장한다.   
> 리스트 원소 한개씩 for문을 돌며 str형식으로 들어가있는 력값이 정수이면(isdigit) 그 정수를 num에 int형으로 변형하여 저장하고, 입력값이 문자이면(isalpha) 보너스(S,D,T) 중 어느것에 해당하는지 파악하고 각 조건에 따라 점수를 1제곱,2제곱,3제곱 해준 뒤 ans 리스트에 저장한다.
> 입력값이 * 또는 # 인 경우, 옵션 중 어느것에 해당하는지 파악하고 각 조건에 따라 스타상이면 한번 더 이전에도 점수가 있으면 두번의 경우 모두 점수 2배를 해준다. 아차상(#)이면 마지막 점수에 -1을 곱해서 점수를 빼준다.
> - 점수,보너스,옵션 조건에 따라서 해당하는 연산만 진행해주는 됐던 문제라 큰 어려움은 없이 해결할 수 있었던거 같다.   
   
      
   ## 마법사 상어와 파이어스톰
### BJ20058
   
> - 딱봐도 어려워보였지만 이번에는 최대한 시도해보려고 이전에 봤던 상어 문제들을 참고하며 혼자 코드를 작성해봤다. 그런데 도저히 배열을 회전시키는 부분을 어떻게 짜야될지 모르겠어서 다른 사람의 풀이를 참고했다.   
> 웬걸 4중 for문을 돌리던데 풀이 설명도 읽어보고 코드도 천천히 봤지만 배열 회전 이후에 얼음을 녹이는 것과 BFS를 이용해서 남아있는 전체 얼음의 합, 가장 많이 남은 얼음 덩어리의 크기를 구하는 것은 어느정도 이해가 가는데, 배열을 돌리는 부분은 읽고서도 L의 값에 따라서 2^L 만큼씩 배열을 건너뛰며 회전시키는 부분과, 90도 회전시킨 후에는 격자 사각형 내에서의 x축과 y축 위치가 달라지는 점을 떠올리는 것 뿐만 아니라 코드로 작성하는 부분도 많이 어렵다고 생각했다.
> - 스터디를 통해 여러 상어문제들을 접해오고 있지만 여전히 혼자서 해결할 수 있는 수준은 아닌것 같다.      


   ## 카카오 프렌즈 컬러링북
### PG 1829
   
- 프로그래머스에 들어가서 파이썬으로 언어변경을 하려니 파이썬이 없길래 사실 건들지도 않았다.. 문제는 좋은 문제라고 하니 오랜만에 다시 cpp로 도전해봐야겠다.
   
