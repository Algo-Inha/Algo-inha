# 시험 감독
## BJ 13458

```c++
for (int i = 0; i < n; i++)
	{
		if (arr[i] <= b)
			sum++;
		else
		{
			arr[i] = arr[i] - b;
			sum++;

			if (arr[i] % c == 0)
				sum += arr[i] / c;
			else
				sum += (arr[i] / c) + 1;
		}
	}	
  ```
  
  - 맨 처음에는 sum 변수를 int형으로 선언해줘서 메모리 초과가 났었다. 그래도 비교적 짧은 시간안에 해결할 수 있었던 문제였다.

   
# 1,2,3 더하기
## BJ 9095
- > `점화식`, `DP`

```c++
num[1] = 1;		// 1
num[2] = 2;		// 1+1, 2
num[3] = 4;		// 1+1+1, 1+2, 2+1, 3
     
 for (int i = 4; i <= N; i++)
	{
		num[i] = num[i - 1] + num[i - 2] + num[i - 3];		// 점화식
	}
```
- 1,2,3을 만드는 방법의 수를 구하고 위와 같은 점화식을 통해 해결하였다.
- 이전에 자구나 알고 수업에서 같은 문제에 대해 설명을 들은적이 있어서 점화식을 써야한다는 것을 알 수 있었다.

   
# 동전 바꿔주기
## BJ2624
- > `점화식`, `DP`

```c++
sort(v.begin(), v.end(), compare);

	for (int i = 0; i < k; i++)
	{
		for (int j = 0; j <= T; j++)
		{
			if (j == 0)
				dp[i][j] = 1;
			else if (i == 0)
			{
				if (j % v[i].first == 0 && j / v[i].first <= v[i].second)
					dp[i][j] = 1;
			}
			else
			{
				for (int k = 0; k <= v[i].second; k++)
				{
					if (k * v[i].first > j)
						break;
					else
						dp[i][j] += dp[i - 1][j - k * v[i].first];
				}
			}
		}
	}

```
- 해당 문제의 경우 꽤 많은 시간을 들였는데 결국 혼자서는 해결하지 못했다.
- 금액과 동전 갯수를 vector 사용하여 pair로 만들고 금액 내림차순으로 정렬한 뒤 반복문을 통해 해결하면 되겠다는 생각까지는 할 수 있었지만
반복문 안쪽의 if문의 조건을 걸어주는 부분에서 막혀서 점화식을 적용하는 부분은 인터넷의 풀이를 참고했다.
- dp를 2차원 배열이 아닌 1차원 배열로 푸는 방법도 있던데 그 방법이 조금은 더 간단해보여서 업로드 이후에 다시 한번 코드를 볼 예정이다.



